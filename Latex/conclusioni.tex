\chapter{Conclusioni}
Il lavoro svolto ha raggiunto gli obiettivi che erano stati prefissati.
Da un lato è stato definito un nuovo insieme di sistemi a eventi discreti, chiamati sistemi attivi complessi (SAC) e ne è stata fornita una specifica formale. I SAC sono stati concepiti come estensione dei sistemi attivi tradizionali, in quanto formati da una rete di questi ultimi, secondo una topologia gerarchica. Questo modello è stato suggerito dal comportamento di molti sistemi reali che possono essere descritti a diversi livelli di astrazione. 
D'altro canto è stato sviluppato un software in grado di calcolare le diagnosi di questi nuovi sistemi, secondo due metodi risolutivi. Il metodo greedy è stato ottenuto come naturale ampliamento dell'algoritmo diagnostico dei sistemi attivi tradizionali, mentre il metodo lazy è stato concepito al fine di migliorarne l'efficienza. Il confronto sperimentale tra le due tecniche, infatti, ha mostrato come a fronte di una crescita delle dimensioni del sistema, l'algoritmo greedy fosse inefficiente, consumando una quantità di memoria e un tempo di esecuzione esponenziali nel numero di componenti totali. L'algoritmo lazy, invece, non possiede un comportamento siffatto, ma trae vantaggio dalla topologia del sistema e produce la diagnosi in un unico passo bottom-up lungo la gerarchia del sistema. La complessità di questo algoritmo si stabilizza alla linearità per nodi di dimensione costante, potendo risolvere problemi che attraverso il metodo greedy non sarebbero affrontabili nella pratica.
A fronte di questi risultati positivi, il lavoro svolto può essere esteso in molteplici direzioni.

\newpage
\section{Sviluppi futuri}

\subsection{Parallelizzazione della diagnosi lazy}
Il metodo di diagnosi lazy ricostruisce in successione i comportamenti dei singoli nodi che compongono il sistema, seguendo un ordinamento topologico dell'albero che caratterizza l'interazione dei nodi. Un ordinamento topologico totale, tuttavia, non è strettamente necessario, in quanto è sufficiente fornire un ordinamento parziale. Il calcolo dei behavior non vincolati è eseguito uno indipendentemente dall'altro; questo suggerisce in modo naturale una parallelizzazione in fase diagnostica. Una volta ricostruiti i comportamenti dei nodi foglia, allo stesso modo il livello superiore della gerarchia è composto da nodi che, sebbene siano vincolati dal comportamento dei nodi sottostanti, non sono vincolati tra loro. Anche la ricostruzione del loro comportamento, quindi, può avvenire in parallelo. Procedendo in questo modo, è possibile effettuare una diagnosi in parallelo sui diversi nodi appartenenti allo stesso livello dell'albero. Questo metodo se implementato, causerebbe un ulteriore miglioramento nelle prestazioni del calcolo, rendendo l'algoritmo linearmente dipendente dal numero di livelli nella topologia del sistema, piuttosto che dal numero di nodi totale. 

\subsection{Aumento del preprocessing}
La fase di preprocessing permette di effettuare dei calcoli in fase di modellazione, evitando di spendere risorse nella successiva fase di diagnosi. L'aumento del calcolo in fase precedente potrebbe consistere nella generazione delle interfacce, la quale può richiedere delle risorse computazionali in alcuni casi costose, trattandosi di un algoritmo analogo alla subset construction. Attualmente le interfacce sono generate a partire dai behavior dei nodi, ma nulla vieta che tali interfacce possano essere generate partendo dai behavior space, che descrivono il comportamento prescindendo dall'osservazione, nota soltanto nella successiva diagnosi. Sebbene la generazione del behavior space è stata scartata nel metodo greedy poiché non praticabile nemmeno offline, la costruzione del behavior space del singolo nodo non dovrebbe essere altrettanto estenuante, assumendo una dimensione del singolo nodo limitata. In fase diagnostica le transizioni di interfaccia attuabili dovranno però essere selezionate in base all'osservazione data: parte delle interfacce costituirà una evoluzione inconsistente con l'osservazione temporale ed andrà scartata. Si noti che in letteratura sono presenti metodi diagnostici che calcolano un automa, detto diagnosticatore, derivato dal behavior space dell'intero sistema. Sebbene questo renda la successiva diagnosi lineare, la generazione di tale automa offline non è praticabile per problemi di dimensione reale.


\subsection{Variazioni nella topologia del sistema}
Nell'ambito di questo lavoro di tesi è stato analizzato il caso di sistemi attivi connessi tra loro in maniera gerarchica, formando un albero. Questa topologia particolare, tuttavia, può essere facilmente estesa al caso più generale di grafo aciclico. Anche in questo contesto è possibile ricostruire il comportamento dei nodi non vincolati, proseguendo in modo analogo a quanto descritto nella trattazione. Un'attenzione particolare deve essere prestata, tuttavia, nel caso in cui un nodo abbia più di un genitore, cioè influenzi più di un altro nodo del sistema. In questo caso la ricostruzione dei behavior dei nodi genitori deve essere effettuata in maniera sincronizzata, nel senso che un cambiamento di stato dell'interfaccia relativa al nodo figlio deve valere contemporaneamente  per tutti i nodi padre, altrimenti la diagnosi potrebbe avere delle soluzioni aggiuntive non sound. La ricostruzione prosegue allo stesso modo del caso di topologia ad albero: se vi sono più nodi radice, il behavior di ognuno di questi deve essere decorato, e le rispettive diagnosi combinate tra loro.\\
Un problema più complicato si verifica quando il sistema costituisce un generico grafo ciclico. In questo caso non è possibile effettuare semplicemente un processo bottom-up: si sceglie un nodo di partenza, si ricostruisce il comportamento relativo e la corrispondente diagnosi; successivamente, in caso esso sia influenzato da un altro nodo, il comportamento e l'interfaccia verranno potati opportunamente, in modo da essere consistenti con i pattern event ricevuti. Il processo quindi si sviluppa percorrendo i link che collegano i nodi un numero finito di volte, fino a quando il pruning non raggiunge una situazione di stabilità. 

\subsection{Osservazioni incerte}
In questo lavoro, le osservazioni dei nodi sono assunte essere sequenze lineari di label osservabili. In sistemi reali, tuttavia, un'osservazione potrebbe consistere in un ordinamento parziale delle label ricevute, anziché un ordinamento totale. In questo caso l'osservazione sarebbe percepita come un grafo orientato aciclico, invece di una semplice sequenza. Altri tipi di incertezze potrebbero riguardare il contenuto dell'osservazione: una label incerta potrebbe essere presente o meno nell'osservazione. Una volta delineato il grafo aciclico relativo all'osservazione, la consumazione di essa può essere monitorata generando un corrispondente automa, chiamato \emph{index space}, le cui transizioni sono percorse in corrispondondenza delle label osservate.


\subsection{Monitoring}
Nell'ambito di questo lavoro il focus è sulla cosiddetta diagnosi a posteriori, la quale avviene dopo un'osservazione completa del sistema, a seguito della quale viene calcolato l'insieme di diagnosi candidate. In un sistema reale, come ad esempio una centrale nucleare o una rete elettrica nazionale, il sistema difficilmente può essere pensato in uno stato quiescente a seguito del quale operare la diagnosi. L'osservazione in questi casi verrà ricevuta passo a passo e il compito della diagnosi, detta in questo ambito monitoring, consiste nel dare a seguito di una singola label di osservazione le diagnosi candidate in tempo reale, durante l'evoluzione del sistema. Estendendo il lavoro in questa direzione si potrebbe dare un metodo utile in applicazioni reali di questo tipo.