\chapter{Implementazione}
L'architettura software del progetto di questa tesi è composta da tre moduli principali:
\begin{enumerate}
\item \verb|SpecificationLanguage|, che comprende un compilatore per il linguaggio di specifica e il preprocessing dei pattern space;
\item \verb|GreedyDiagnosis|, che rappresenta il motore diagnostico greedy;
\item \verb|LazyDiagnosis|, che attua la tecnica di ricostruzione lazy.
\end{enumerate}

La specifica dell'istanza di un sistema attivo complesso di cui si vuole determinare le diagnosi è espressa tramite un linguaggio creato ad hoc, la cui grammatica è fornita nell'appendice \ref{bnf}. Un esempio di specifica, relativo al problema diagnostico \ref{ex:prob_diagn}, è riportato nell'appendice \ref{spec_ex}.
Durante la lettura del file di specifica, sono generate le classi opportune e sono effettuati i controlli del caso. Se questa procedura di compilazione non contiene errori (lessicali, sintattici o semantici), viene effettuato il preprocessing offline del problema, durante il quale si creano gli automi relativi ai pattern space. Tutte le informazioni ottenute vengono salvate su appositi file, in modo che non sia necessario dover effettuare nuovamente la procedura in fase di lavoro online, ovvero quando viene avviata la macchina diagnostica, sia essa in modalità greedy o lazy. 
La procedura diagnostica legge i file generati da una precedente compilazione della specifica  e genera le soluzioni candidate. 
Il linguaggio di programmazione adottato è il C++, che è stato scelto in quanto buon compromesso tra le esigenze di efficienza richieste dal problema e il livello di astrazione tipico della programmazione ad oggetti.

\section{Rappresentazione degli automi}
Per la rappresentazione degli automi è stata scelta una libreria esterna che fornisse da un lato delle strutture dati e dei metodi efficienti, dall'altro che fosse quanto più generica e personalizzabile, dal momento che gli automi necessari alle tecniche risolutive possiedono vari tipi di informazione negli stati e nelle transizioni. La libreria ASTL(\emph{Automata Standard Template Library})\cite{web:astl} soddisfa entrambe le esigenze. Le due classi principali di questa libreria utilizzate nell'implementazione sono:
\begin{itemize}
\item \verb|DFA_map<SIGMA,TAG>| rappresenta automi deterministici ed è implementata memorizzando le transizioni di uno stato in uno standard \verb|map|, associando i relativi simboli dell'alfabeto agli stati raggiunti. Dato che la struttura \verb|map| costituisce un albero binario, le operazioni di accesso, inserimento e cancellazione sono effettuate in un tempo logaritmico $\mathcal{O}(\log n)$ rispetto al numero di elementi contenuti.  Si tratta di un buon compromesso tra tempi richiesti dalle operazioni e memoria occupata.
\item \verb|NFA_mmap<SIGMA,TAG>|, rappresenta automi non deterministici. Le transizioni sono memorizzate per mezzo di \verb|multimap|, le cui principali operazioni hanno complessità logaritmica.
\end{itemize}
Il template \verb|SIGMA| permette di specificare l'alfabeto cui i simboli di transizione appartengono, mentre il template \verb|TAG| consente di associare ad uno stato delle informazioni satelliti generiche. 
Per la visualizzazione degli automi, in fase di debug nonché per le illustrazioni di questa trattazione, sono stati utilizzati metodi che generano file scritti nel linguaggio \verb|dot|, interpretati dal programma \emph{Graphviz}\cite{web:graphviz} che ne genera la rappresentazione.

\section{Classi condivise}
I tre moduli che compongono l'architettura software ideata hanno delle classi tra loro condivise, in modo da operare sulle stesse strutture dati. Si tratta di quegli oggetti che sono creati in fase di compilazione del file di specifica e che successivamente sono utilizzati al fine di avere le informazioni necessarie nella fase diagnostica.
Nel seguito vengono descritte tali classi.
\begin{itemize}

\item \verb|ComponentModel|\\ 
Rappresenta il modello di un componente. Ha come attributi la stringa del nome che lo identifica e vettori di stringhe contenenti i nomi di eventi, terminali di input, terminali di output e stati. Possiede un vettore di oggetti \verb|Transition| che contengono le informazioni relative ad ogni transizione del modello. L'attributo \verb|automaton| indica l'automa risultante dal modello comportamentale descritto dalle transizioni. Si noti che l'automa non è provvisto di stato iniziale, in quanto questa informazione è definitiva solo nella specifica del problema diagnostico.

\item \verb|NetComponent|\\
Rappresenta un componente generico nel modello di un nodo. Ha come attributi il nome, che lo identifica nel particolare modello di nodo nel quale è contenuto, e un riferimento ad un oggetto \verb|ComponentModel| che ne rappresenta il modello topologico e comportamentale.

\item \verb|Component|\\
Rappresenta un componente concreto del problema diagnostico. \'E una classe derivata da \verb|NetComponent| e possiede gli attributi aggiuntivi relativi all'automa ottenuto dal modello di componente associato, con l'informazione addizionale dello stato iniziale, e gli oggetti \verb|Terminal| riferiti ai terminali di input e output della sua topologia.

\item \verb|NetworkModel|\\
Rappresenta il modello di un nodo. Possiede gli attributi seguenti:
\begin{itemize}
\item \verb|name|: nome che identifica il modello del nodo;
\item \verb|components|: vettore di oggetti \verb|NetComponents| contenuti nel modello;
\item \verb|inputs| e \verb|outputs|: specificano i nomi dei terminali di input e dei terminali di output del modello del nodo;
\item \verb|links|: contiene l'elenco dei link che connettono tra loro i componenti e i terminali di input del nodo ai terminali di input dei componenti che gestiscono i pattern event in ingresso;
\item \verb|patterns|: vettore di oggetti di tipo \verb|Pattern|, ognuno dei quali rappresenta una dichiarazione di un pattern event che è generato in corrispondenza di un terminale di output del nodo;
\item \verb|initials|: nomi degli stati iniziali per ogni componente del nodo;
\item \verb|viewer|: \verb|map| tra nomi di transizioni di componenti e corrispondenti label osservabili;
\item \verb|ruler|: \verb|map| tra nomi di transizioni di componenti e corrispondenti label di guasto;
\item \verb|pattern_space|: vettore di automi che costituiscono i pattern space del nodo;
\item \verb|languages|: vettore di linguaggi, ognuno dei quali costituito da un insieme di stringhe recanti i nomi delle transizioni appartenenti al linguaggio di una o più dichiarazioni di pattern.
\end{itemize}
Si noti che le informazioni relative agli stati iniziali, al viewer e al ruler possono non essere presenti oppure venire sovrascritte nelle successive dichiarazioni del sistema o del problema diagnostico.
\item \verb|Pattern|\\
Rappresenta una dichiarazione di pattern e contiene gli attributi relativi al nome del pattern event, al nome del terminale di destinazione del pattern event, un attributo booleano che indica se il linguaggio associato al pattern è massimo, ovvero costituito dall'insieme di tutte le transizioni di tutti i componenti del nodo, e un vettore di elementi del linguaggio.
\item \verb|Terminal|\\
rappresenta un terminale di un componente o di un nodo. \'E caratterizzato da una stringa del nome, una relativa al valore contenuto (evento), e un vettore di riferimenti a terminali ad esso connessi.
\item \verb|Transition|\\ 
Rappresenta la transizione di un modello di componente. Ha come attributi la stringa relativa al suo nome identificativo, una coppia di stringhe indicanti il nome dell'evento in ingresso e il terminale di input, un vettore di coppie di stringhe indicanti il nome dell'evento di uscita e il terminale di output, e la coppia del nome di stati sorgente-destinazione coinvolti nella transizione. 
Possiede attributi e metodi (l'operatore di confronto e di uguaglianza) in modo da permetterne l'utilizzo come alfabeto di un automa della libreria ASTL, come mostrato in figura \ref{class_trans}.
\item \verb|NetTransition|\\
Rappresenta la transizione di un componente del modello di un nodo. Ha come attributi il riferimento alla transizione del modello di componente del particolare componente del nodo, e un riferimento a quest'ultimo. Il nome è ottenuto, per mezzo del costruttore dell'oggetto, concatenando il nome della transizione associata e, tra parentesi, il nome del componente del nodo associato.
\item \verb|SysTransition|\\
Rappresenta la transizione di un componente concreto di un nodo del problema diagnostico. \'E una classe derivata da \verb|NetTransition| e presenta i seguenti attributi aggiuntivi:
\begin{itemize}
\item \verb|node|: il riferimento nodo del sistema relativo alla transizione;
\item \verb|input_event|: una coppia formata dal nome di un evento e dall'indice della tupla di terminali di input dei componenti del sistema (utile per la diagnosi greedy);
\item \verb|output_events|: un vettore di coppie formate dal nome di un evento e dall'indice della tupla di terminali di input dei componenti del sistema (utile per la diagnosi greedy);
\item \verb|lazy_input_event|: una coppia formata dal nome di un evento e dall'indice della tupla di terminali di input dei componenti del nodo coinvolto (utile per la diagnosi lazy);
\item \verb|lazy_output_events|: un vettore di coppie formate dal nome di un evento e dall'indice della tupla di terminali di input dei componenti del nodo coinvolto (utile per la diagnosi lazy).
\end{itemize}
\item \verb|System|\\
Rappresenta la specifica del sistema. Possiede i seguenti attributi:
\begin{itemize}
\item \verb|name|: nome del sistema;
\item \verb|node_list|: vettore dei nodi del sistema;
\item \verb|emergence|: lista delle dichiarazioni di link tra nodi del sistema;
\item \verb|dependency_graph|: grafo che rappresenta la topologia del sistema;
\item \verb|acyclic|: attributo booleano di valore \verb|true| se la topologia del sistema è aciclica e permette quindi la diagnosi lazy.
\end{itemize}
\item \verb|SystemNode|\\
Rappresenta un nodo del sistema ed è caratterizzato da un nome identificativo e un riferimento all'oggetto di tipo \verb|NetworkModel| che ne costituisce il modello; possiede inoltre gli attributi relativi agli stati iniziali dei suoi componenti, al viewer e al ruler locali, i quali possono essere ereditati dal modello o sovrascritti nella specifica del problema diagnostico.
\item \verb|Problem|\\
Rappresenta il problema diagnostico e possiede un nome, una lista di nodi del problema e un vettore di indici  che indica l'ordinamento topologico dei nodi, al fine di poter effettuare la diagnosi lazy.
\item \verb|ProblemNode|\\
Rappresenta un nodo del problema diagnostico. Possiede i seguenti attributi:
\begin{itemize}
\item \verb|name|: nome del nodo, ottenuto dal nodo del sistema associato;
\item \verb|ref_node|: riferimento al nodo del sistema;
\item \verb|concrete_components|: vettore di componenti concreti;
\item \verb|input_terminals|: vettore di terminali di ingresso fisici del nodo;
\item \verb|output_terminals|: vettore di terminali di uscita fisici del nodo;
\item \verb|observation|: sequenza di label relative all'osservazione locale;
\item \verb|index_space|: automa lineare ottenuto dall'osservazione, utile per eventuali sviluppi futuri nei quali l'osservazione è incerta.
\item \verb|depends|: lista di indici dei nodi dai quali il nodo corrente dipende topologicamente;
\item \verb|patt_map|: mappa un pattern event nel terminale di uscita fisico del nodo;
\item \verb|patt_indexes_map|: mappa un pattern event nell'indice della tupla dei terminali di input di tutto il problema (utile per la diagnosi greedy);
\item \verb|lazy_patt_indexes_map|: mappa un pattern event nell'indice della tupla dei terminali di input del nodo (utile per la diagnosi lazy);
\end{itemize}
La classe contiene inoltre le informazioni definitive riguardanti gli stati iniziali dei componenti, il viewer e il ruler locali, che possono essere ereditati dalla specifica del nodo del sistema.
\item \verb|Utils|, contiene metodi statici di utilità.
\end{itemize}


\begin{figure}[htbp]
\centering
\begin{verbatim}
class Transition : public CHAR_TRAITS<Transition>
{
    std::string name;
    std::pair<std::string,std::string> input_event;
    std::pair<std::string,std::string> s1_s2;
    std::vector<std::pair<std::string,std::string> > out_events;

    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version)
    {
        ar & input_event;
        ar & name;
        ar & out_events;
        ar & s1_s2;
    }
public:
    Transition();
    Transition(std::string n);
    ~Transition();

    std::string get_name() const;
    std::pair<std::string,std::string> get_input_event() const;
    std::pair<std::string,std::string> get_s1_s2() const;
    std::vector<std::pair<std::string,std::string> > get_out_events() const;
    void set_input_event(std::string e,std::string t);
    void set_s1_s2(std::string s1,std::string s2);
    void add_out_event(std::string e,std::string t);

    //required definitions to use a Transition as automata alphabet for astl lib
    typedef Transition char_type;
    typedef long        int_type;
    static const size_t size;
    static bool eq(const char_type &x, const char_type &y) { return x == y; }
    static bool lt(const char_type &x, const char_type &y) { return x < y; }
    bool operator<(const Transition t) const {return name<t.name;}
    bool operator==(const Transition t) const {return name == t.name;}
};
\end{verbatim}
\caption{Classe Transition}
\label{class_trans}
\end{figure}

In figura \ref{fig:comp} è riportato il diagramma UML delle classi \verb|ComponentModel|, \verb|NetComponent| e \verb|Component|.
In figura \ref{fig:trans} è riportati il diagramma UML delle classi \verb|Transition|, \verb|NetTransition| e \verb|Systransition|.
In figura \ref{fig:nodes} è riportato il diagramma UML delle classi \verb|NetworkModel|, \verb|SystemNode| e \verb|ProblemNode|.

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{./Img/implementazione/comp.png}
\caption{Classi dei componenti}
\label{fig:comp}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{./Img/implementazione/trans.png}
\caption{Classi delle transizioni}
\label{fig:trans}
\end{figure}

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.5]{./Img/implementazione/nodes.png}
\caption{Classi dei nodi}
\label{fig:nodes}
\end{figure}

\newpage
\section{Linguaggio di specifica}
Il linguaggio di specifica dei sistemi attivi complessi è fornito, tramite notazione BNF, in appendice \ref{bnf}. 
Il file di specifica è articolato in quattro parti principali:
\begin{itemize}
\item modelli dei componenti, a cui i componenti concreti del sistema si riferiscono;
\item modelli dei nodi, a cui i nodi concreti del sistema si riferiscono;
\item sistema, che istanzia i nodi e definisce i link responsabili dell'invio di pattern event tra di essi;
\item problema, che fornisce informazioni necessarie per il problema diagnostico, come le osservazioni locali dei nodi.
\end{itemize}
I viewer locali, i ruler locali e gli stati iniziali dei singoli nodi possono essere definiti, con eventuale riscrittura, a tre diversi livelli:
\begin{itemize}
\item nella definizione del modello del nodo;
\item nella dichiarazione di un nodo del sistema;
\item nella specifica di un nodo del problema.
\end{itemize}
Questo permette una certa facilità di scrittura, non essendo costretti a dichiarare informazioni di questo tipo, quando esse sono ridondanti.
Il file di specifica viene compilato seguendo le tradizionali fasi ideate per i compilatori dei linguaggi di programmazione:
\begin{enumerate}
\item analisi lessicale, che legge il flusso di caratteri che costituiscono il codice di specifica e raggruppa i caratteri in sequenze significative dette lessemi, quali le parole chiave del linguaggio e gli identificatori;
\item analisi sintattica, che riceve i lessemi dall'analizzatore lessicale per creare una rappresentazione ad albero del codice di specifica, detto albero sintattico;
\item analisi semantica, la quale utilizza le informazioni raccolte nell'albero sintattico in modo da verificare la consistenza del codice di specifica.
\end{enumerate}
Si noti che in questo progetto è possibile articolare una specifica in più file, esplicitando delle dichiarazioni del tipo \verb|#include| per i file che si vogliono incorporare. 
Questo permette il riutilizzo di specifiche già dichiarate precedentemente, aumentando inoltre la leggibilità dei file di specifica.


\subsection{Analizzatore lessicale}
L'analizzatore lessicale (o scanner) è implementato mediante lo strumento \emph{Flex}, il quale permette di dichiarare espressioni regolari che descrivono i pattern per i token, ovvero coppie nome-attributo, ad esempio \verb|<id,breaker>|. La struttura di un programma Flex  è composta da tre parti principali:
\begin{enumerate}
\item dichiarazioni, che include variabili, costanti e definizioni regolari;
\item regole di traduzione, che specificano per ogni pattern dichiarato per mezzo di una espressione regolare le azioni da compiere, ovvero frammenti di codice;
\item funzioni ausiliarie, che possono essere richiamate nelle azioni dei pattern.
\end{enumerate}
Sebbene Flex abbia un'opzione per creare direttamente uno scanner C++, il codice generato spesso non funziona e contiene errori\cite{book:bison} .
La procedura adottata per risolvere questo problema è quella di compilare un programma Flex scritto in linguaggio C per mezzo di un compilatore C++, facendo richiamare poi ad un analizzatore sintattico C++ lo scanner C definito.
La sezione dichiarativa del linguaggio è riportata in figura \ref{code:lex_decl}. In essa si definiscono spazi, delimitatori, commenti di linea (in stile C) e l'espressione regolare che definisce gli identificatori \verb|id|, formata da una lettera a cui seguono altre lettere, numeri oppure il carattere \verb|_|.

\begin{figure}[htbp]
\begin{verbatim}
// The location of the current token.
yy::location loc;

%}
%option noyywrap nounput
%x incl

delimiter	[ \t]
spacing		{delimiter}+
letter		[A-Za-z]
digit		[0-9]
unscore         _
id		{letter}({letter}|{digit}|{unscore})*
eol		\n
comment		\/\/.*

%{
  // Code run each time a pattern is matched.
  # define YY_USER_ACTION  loc.columns (yyleng);
%}
\end{verbatim}
\caption{Dichiarazioni.}
\label{code:lex_decl}
\end{figure}

Le regole di traduzione utilizzate sono principalmente volte a generare i token relativi a parole chiave del linguaggio e gli identificatori.
In corrispondenza di direttive \verb|#include|, il passaggio di lettura al file incluso è operato, come mostrato in figura \ref{code:lex_rules}, creando una pila di buffer. 

\begin{figure}[htbp]
\begin{verbatim}
#include          BEGIN(incl);
<incl>[ \t]*      /* eat the whitespace */
<incl>[^ \t\n]+   
{   /* got the include file name */
    chdir(INPUT_FILE_DIR);
    FILE *file = fopen( yytext, "r" );

    if (file == NULL)
    {
       cout << "Input file error: included file does not exist" << endl;
       exit(1);
    }
    yyin = file;

    yypush_buffer_state(yy_create_buffer( yyin, YY_BUF_SIZE ));
    BEGIN(INITIAL);
}
\end{verbatim}
\caption{Gestione delle direttive di inclusione.}
\label{code:lex_rules}
\end{figure}

Gli spazi e i commenti non invocano alcuna azione, mentre la fine del file attuale toglie dalla pila il buffer corrente, riportando il controllo alla scansione del file precedente da cui la direttiva di inclusione è stata chiamata (figura \ref{code:lex_buff}). Se il buffer corrente è l'unico elemento della pila, il processo di scanning termina ed è generato il token relativo alla fine del file.

\begin{figure}[htbp]
\begin{verbatim}
{spacing}	;
{comment}   ;

{eol}		{loc.lines (yyleng);loc.step();}

<<EOF>>    
{
  yypop_buffer_state();
  if ( !YY_CURRENT_BUFFER )
    return yy::spec_parser::make_END_OF_FILE(loc);;
  
}
\end{verbatim}
\caption{Azioni compiute alla fine del file.}
\label{code:lex_buff}
\end{figure}

Quando viene trovata una parola chiave (come ad esempio \verb|component| e \verb|model|), viene creato il corrispondente token che verrà utilizzato nell'analisi sintattica.
Per quanto riguarda gli identificatori (\verb|id|), il loro token è composto oltre che dalla posizione, dalla stringa che ne rappresenta il nome, memorizzato durante lo scanning nella variabile \verb|yytext| (figura \ref{code:lex_id}).

\begin{figure}[htbp]
\begin{verbatim}
component   return yy::spec_parser::make_COMPONENT(loc);
model       return yy::spec_parser::make_MODEL(loc);
is          return yy::spec_parser::make_IS(loc);


{id}        return yy::spec_parser::make_ID(yytext,loc);
.		    {cout << "Lexical error"; exit(1);}
\end{verbatim}
\caption{Regole di traduzione per parole chiave e identificatori.}
\label{code:lex_id}
\end{figure}

\subsection{Analizzatore sintattico}
L'analizzatore sintattico (parser) è implementato tramite lo strumento \emph{Bison}.
Il file della grammatica \verb|specparser.yy| inizia richiedendo lo skeleton parser deterministico per poter utilizzare direttamente il linguaggio C++, creando il file header della grammatica e specificando il nome della classe del parser.

\begin{verbatim}
%skeleton "lalr1.cc"
%defines
%define parser_class_name {spec_parser}
\end{verbatim}

Per poter utilizzare oggetti C++ come valori semantici della grammatica, deve essere richiesta l'interfaccia \verb|variant|.

\begin{verbatim}
%define api.value.type variant
%define api.token.constructor
%define parse.assert
\end{verbatim}
 
Successivamente sono specificate le dichiarazioni necessarie ai valori semantici. Poiché il parser utilizza la classe driver e viceversa, questa mutua dipendenza è risolta fornendo una \emph{forward declaration}. 

\begin{verbatim}
%code requires
{
...
class spec_driver;
}
\end{verbatim}

L'oggetto driver viene passato al parser e allo scanner tramite referenza.

\begin{verbatim}
%param { spec_driver& driver}
\end{verbatim}

Quindi viene richiesto di tenere traccia della locazione (riga e colonna del file di specifica), passando il nome del file dell'oggetto \verb|driver|.

\begin{verbatim}
%locations
%initial-action
{
  // Initialize the initial location.
  @$.begin.filename = @$.end.filename = &driver.file;
};
\end{verbatim}

La definizione dei token avviene come di seguito.

\begin{verbatim}
%token
COMPONENT
MODEL
IS
...
END_OF_FILE  0  "end of file"
COMMA ","
...
\end{verbatim}

Per ogni terminale e non terminale della grammatica, deve essere specificato un tipo dell'oggetto.

\begin{verbatim}
%token <string> ID "id"
%type <ComponentModel>  comp_model_decl
%type <vector<string> > event_decl
..
\end{verbatim}

Successivamente viene implementata la grammatica del linguaggio, assegnando i valori semantici definiti.

\subsection{Analizzatore semantico}
L'analisi semantica, a differenza di quella lessicale e sintattica, non prevede l'utilizzo di strumenti standard per la sua attuazione, ma è compito del programmatore definirne le regole, in base al significato del linguaggio specificato Nell'ambito di questo progetto, i controlli semantici sono affidati alla classe \verb|spec_driver| (figura \ref{fig:driver}), la quale verifica la consistenza semantica durante il parsing del file, interrompendone l'esecuzione in caso di errori. 

\begin{figure}[htbp]
\centering
\includegraphics[scale=0.6]{./Img/implementazione/driver.png}
\caption{Classe specdriver}
\label{fig:driver}
\end{figure}

La classe possiede, tra gli altri, i metodi \verb|semantic_checks|, implementati in \emph{overloading} per i seguenti tipi di parametro d'ingresso:
\begin{enumerate}
\item \verb|ComponentModel|: verifica che non vi siano identificatori multipli per le liste di eventi, terminali di input e di output e stati; nelle dichiarazioni delle transizioni, verifica che il nome degli eventi, dei terminali e degli stati siano stati precedentemente definiti. 
\item \verb|NetworkModel|: verifica l'unicità del nome dei componenti, dei terminali e dei nomi dei pattern;
verifica che i terminali e i componenti dei link siano definiti. Verifica che non vi siano più link entranti nello stesso terminale di input. Verifica l'esistenza delle transizioni utilizzate nei pattern, nel viewer e nel ruler (se presenti), oltre all'esistenza degli stati iniziali dei componenti dichiarati.
\item \verb|System|
\item \verb|SystemNode|
\item \verb|Problem|
\item \verb|ProblemNode|
\end{enumerate}


\subsection{Generazione dei pattern space}
La principale azione compiuta in fase offline, ovvero in un momento antecedente la diagnosi, è la generazione dei pattern space dei modelli di nodi definiti, come descritto nel paragrafo \ref{pts_construction}. 
Il primo passo di questo algoritmo consiste nella costruzione di un automa equivalente all'espressione regolare definita nella dichiarazione di pattern. Un metodo noto consiste nella costruzione di Thompson descritta nel paragrafo \ref{thompson}. 
Per questo scopo, è stata utilizzata la libreria \emph{Grail+}\cite{web:grail}, una libreria C++ che permette di definire espressioni regolari e convertirle in automi con un linguaggio equivalente.
La conversione avviene utilizzando la sintassi presentata in figura \ref{code:patodfa}.

\begin{figure}[htbp]
\begin{verbatim}
fm<int> patodfa(std::string regex)
{
    re<int> r;
    istringstream str(regex);
    str >> r;
    fm<int> dfa;
    r.retofm(dfa);
    dfa.subset();

    return dfa;
}
\end{verbatim}
\caption{Passaggio da espressione regolare ad automa}
\label{code:patodfa}
\end{figure}

Data una stringa in ingresso, la funzione implementata inserisce tale stringa in un oggetto della classe \verb|re|(\emph{regular expression}), parametrizzato per mezzo di un template che indica l'alfabeto di appartenenza dei simboli dell'espressione. 
Dato che gli alfabeti possibili per questa libreria erano esclusivamente di tipo \verb|char| o \verb|int|, è stato scelto quest'ultimo (poiché 256 simboli possibili potevano non essere sufficienti in applicazioni di dimensioni ragguardevoli), mantenendo una corrispondenza biunivoca tra ogni intero e una transizione, coinvolta nella dichiarazione del pattern, relativa ad un componente del nodo. La conversione da espressione regolare ad automa a stati finiti avviene applicando all'oggetto che rappresenta l'espressione regolare il metodo \verb|retofm|, che crea l'automa nell'oggetto della classe \verb|fm|(\emph{finite machine}) passato come parametro. A seguito della conversione, l'automa è determinizzato applicando il metodo \verb|subset|, il quale esegue la subset construction descritta nel paragrafo\ref{subset}.
Successive manipolazioni dei diversi automi ottenuti dai pattern dichiarati permettono di unirli, aggiungere le $\epsilon$-transizioni opportune e determinizzare il risultato. L'automa finale viene poi convertito in un automa equivalente, utilizzando le strutture dati della libreria ASTL. Infatti, la libreria Grail+, sebbene utile poiché implementa la costruzione di Thompson, non sembrava indicata ad un utilizzo negli algoritmi di diagnosi, in quanto non permette estensioni per quanto riguarda i dati satellite associati a transizioni e stati dell'automa.
La minimizzazione finale del pattern space è implementata nel metodo \verb|Utils::minimize_by_partition|, che esegue una minimizzazione tenendo conto dei tag associati ai nodi finali dell'automa.

\subsection{Salvataggio dei dati compilati}
Una volta che il file di specifica è stato processato, le classi opportune sono state create e i controlli semantici sono andati a buon fine, la procedura di elaborazione offline termina creando dei file binari contenenti tutte le informazioni utili alla successiva fase diagnostica, ovvero tutti gli oggetti istanziati per il problema specificato. La scrittura di questi dati, chiamata serializzazione, è una procedura piuttosto complessa se implementata manualmente in C++, in quanto deve gestire puntatori ed evitare ridondanza. Per questo è stata adottata la libreria \emph{Serialization}, fornita dalla collezione \emph{Boost}\cite{web:boost}. Essa permette di salvare un oggetto con semplici modifiche della classe a cui esso appartiene.
Ad esempio, la definizione della classe \verb|ComponentModel| è stata modificata aggiungendo le istruzioni riportate in figura \ref{code:serialize}. Per ogni attributo della classe, viene specificata la lettura e la scrittura in un oggetto di tipo \verb|Archive|, appartenente alla libreria. \'E necessario esplicitare l'operazione per ogni attributo della classe, in modo da poter salvare lo stato dell'oggetto corrente; eventuali attributi non salvati avranno un valore impredicibile. Quando l'oggetto corrisponde ad un archivio di output, l'operatore \verb|&| indica la scrittura, mentre nel caso di un archivio di input esso indica l'operazione di lettura. Le modifiche attuate permettono quindi sia la scrittura su file che la lettura operata durante la successiva fase diagnostica.

\begin{figure}[htbp]
\begin{verbatim}
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/text_iarchive.hpp>

class ComponentModel{
    friend class boost::serialization::access;
    template<class Archive>
    void serialize(Archive & ar, const unsigned int version)
    {
        ar & autom_states;
        ar & name;
        ar & automaton;
        ar & events;
        ar & inputs;
        ar & outputs;
        ar & states;
        ar & trans;
    }
\end{verbatim}
\caption{Modifiche apportate alla classe ComponentModel per la serializzazione.}
\label{code:serialize}
\end{figure}

Il programma sviluppato salva le informazioni precompilate in quattro file distinti:
\begin{itemize}
\item un file contenente tutti i modelli dei componenti (\verb|component_models.dat|);
\item un file che comprende tutti i modelli dei nodi (\verb|network_models.dat|);
\item un file che racchiude la specifica del sistema (\verb|system.dat|);
\item un file contenente le informazioni del problema diagnostico con le osservazioni temporali (\verb|problem.dat|).
\end{itemize}
Per eseguire la scrittura di un oggetto è sufficiente dare istruzioni simili a quelle riportate in figura \ref{code:serialize_main}, nella quale è salvato su file il \verb|vector| dei modelli dei componenti utilizzati nel sistema.

\begin{figure}[htbp]
\begin{verbatim}
{
    std::ofstream ofs("../../CompiledData/component_models.dat");
    boost::archive::text_oarchive oa(ofs);
    // write class instance to archive
    oa << driver.components;
    // archive and stream closed when destructors are called
}
\end{verbatim}
\caption{Serializzazione.}
\label{code:serialize_main}
\end{figure}

Si noti che la libreria \emph{Serialization} permette di salvare, senza il bisogno di istruzioni aggiuntive, oggetti appartenenti alla Standard Template Library, quali ad esempio \verb|vector, map, list, set|. Per quanto riguarda il salvataggio di puntatori, al fine di evitare ridondanza, la libreria salva l'oggetto puntato un'unica volta, mantenendone i riferimenti.


\section{Macchina diagnostica}

\subsection{Lettura dei dati precompilati}
La fase diagnostica necessita degli oggetti generati dal precedente passo di compilazione dei file di specifica. La lettura delle informazioni salvate avviene in modo simile a quanto fatto per la scrittura, come si può vedere in figura \ref{code:read_files}.


\begin{figure}[htbp]
\begin{verbatim}
vector<ComponentModel> components;
{
    // create and open an archive for input
    std::ifstream ifs("../../CompiledData/component_models.dat");
    boost::archive::text_iarchive ia(ifs);
    // read class state from archive
    ia >> components;;
    // archive and stream closed when destructors are called
}
\end{verbatim}
\caption{Lettura dai file binari e memorizzazione degli oggetti salvati.}
\label{code:read_files}
\end{figure}

\subsection{Modalità greedy}

\subsubsection{Classi}

\begin{figure}[htbp]
\begin{verbatim}
class BehaviorState
{
    int number;
    bool marked;
public:
    int n_comps, n_inputs, n_pts, n_isp;

    vector<int>  S;
    vector<std::string> E;
    vector<int>  P;
    vector<int>  I;

    std::set<std::set<std::string> > candidate_diagnosis;

    BehaviorState();
    BehaviorState(int n, int m, int k, int i);
    ~BehaviorState();

    BehaviorState copy();
    void set_E(vector<Terminal*> terms);
    bool empty_terminals();
    bool is_marked() const;
    int get_number() const{return number;}
    void mark_state() { marked = true; }
    void set_number(int n) { number = n; }
};

std::ostream& operator<<(std::ostream& out, const BehaviorState& s);
\end{verbatim}
\caption{Classe BehaviorState.}
\label{code:greedy_bhvstate}
\end{figure}


\subsection{Modalità lazy}

\subsubsection{Classi}

\begin{figure}[htbp]
\begin{verbatim}
class BehaviorState
{
    int number;
    bool marked;
public:
    int n_comps, n_inputs, n_pts, n_intfcs;

    vector<int>  S;
    vector<std::string> E;
    vector<int>  P;
    int I;
    vector<int>  interfaces;

    std::set<std::set<std::string> > candidate_diagnosis;

    std::set<std::set<std::string> > interface_delta;

    BehaviorState();
    BehaviorState(int n, int m, int k, int i);
    ~BehaviorState();

    bool empty_terminals();
    bool is_marked() const;
    int get_number() const{return number;}
    void mark_state() { marked = true; }
    void set_number(int n) { number = n; }
};

std::ostream& operator<<(std::ostream& out, const BehaviorState& s);
\end{verbatim}
\caption{Classe BehaviorState.}
\label{code:lazy_bhvstate}
\end{figure}


\begin{figure}[htbp]
\begin{verbatim}
class InterfaceState
{

    std::set<unsigned int> states;
    astl::NFA_mmap<InterfaceTrans,BehaviorState> *automaton;
    std::map<unsigned int, unsigned int> state_map;
    std::set<std::set<std::string> > delta;
    std::set<std::string> pattern_events;
public:
    InterfaceState();
    InterfaceState(std::set<unsigned int> s);
    ~InterfaceState();

    std::set<unsigned int> get_states() const;
    astl::NFA_mmap<InterfaceTrans,BehaviorState>* get_automaton() const;
    std::map<unsigned int, unsigned int> get_state_map() const;
    std::set<std::set<std::string> > get_delta() const;
    std::set<std::string> get_pattern_events() const;

    void set_automaton(astl::NFA_mmap<InterfaceTrans,BehaviorState> *a);
    void set_state_map(map<unsigned int, unsigned int> smap);
    void set_delta(std::set<std::set<std::string> > d);
    void set_pattern_events(std::set<std::string> events);

    void delete_automaton();
};


std::ostream& operator<<(std::ostream& out, const InterfaceState& s);
\end{verbatim}
\caption{Classe InterfaceState.}
\label{code:lazy_interstate}
\end{figure}