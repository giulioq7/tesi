\chapter{Sistemi Attivi Complessi}
In questo capitolo vengono presentate definizioni e modelli che descrivono i sistemi attivi complessi, visti come estensione dei sistemi attivi tradizionali descritti precedentemente. Un sistema attivo complesso è una gerarchia di sistemi attivi tra loro comunicanti. Questo modello si ispira a molti sistemi naturali, fisici, economici e sociali, dei quali è possibile fornire un modello stratificato, in base a diversi livelli di astrazione. Nei sistemi biologici, ad esempio, il comportamento può essere descritto a basso livello dalle interazioni fra le cellule, oppure ad un livello più alto tra i tessuti, o ancora in maniera più astratta studiando il funzionamento degli organi. Nell'ambito dei linguaggi di programmazione a oggetti, ad esempio, a basso livello vi sono le singole istruzioni, a livello più alto i metodi, ad un più alto livello ancora le classi e le interfacce. 
L'attributo ``complesso'' si riferisce, più che alla quantità di componenti presenti nel sistema (che comunque possono essere molti), all'organizzazione gerarchica e alla conseguente stratificazione del comportamento globale del sistema.
Ogni livello della gerarchia di sistemi siffatti ha una evoluzione indipendente dagli altri, eccetto alcune informazioni che giungono dai livelli sottostanti. Ogni livello, in altre parole, ha un comportamento emergente che è impredicibile dalla semplice conoscenza del comportamento dei singoli componenti. Queste informazioni che giungono ai livelli superiori sono rese nel modello dei sistemi attivi complessi attraverso pattern event, che si verificano quando determinate configurazioni delle transizioni dei componenti sottostanti si verificano, soddisfacendo particolari espressioni regolari.

\newpage
\section{Definizioni}
Un sistema attivo complesso (SAC) è una gerarchia di sistemi attivi. In un SAC, vi sono due tipi di comunicazione: tra componenti dello stesso sistema attivo e tra differenti sistemi attivi. 
I componenti di un sistema attivo interagiscono tra loro in base a determinati eventi che giungono o da componenti adiacenti (eventi interni), o da altri sistemi attivi collegati (pattern event) o dal mondo esterno al sistema (eventi esterni). Questi eventi innescano delle transizioni nei componenti, le quali a loro volta generano nuovi eventi, formando una sequenza di transizioni detta traiettoria del SAC.
Analogamente ai sistemi attivi tradizionali, un sistema attivo complesso può essere in uno stato quiescente, nel quale nessun evento si verifica e conseguentemente non vengono innescate transizioni dei componenti.
Il SAC diviene reattivo nel momento in cui si verifica un evento esterno che può essere consumato da un componente. In tale circostanza la transizione di un componente modifica lo stato del sistema, dove lo stato è caratterizzato dalla composizione di tutti gli stati dei componenti, dagli eventi non ancora consumati presenti nei terminali di input, e dagli stati relativi agli automi (pattern space) responsabili del matching delle espressioni regolari generanti i pattern event. 

\subsection{Nodi}
Un sistema attivo complesso è composto da un insieme di sistemi attivi che interagiscono tra loro. Ogni singolo sistema attivo è detto nodo, in quanto costituisce un nodo nella gerarchia che costituisce la topologia del sistema.
Il modello di un nodo, a cui più istanze di nodi possono fare riferimento, possiede tutti gli attributi di un sistema attivo, con l'aggiunta di alcuni elementi:
\begin{itemize}
\item un insieme $I$ di terminali di input, nei quali giungono pattern event generati da nodi del livello inferiore;
\item un insieme $O$ di terminali di output, nei quali vengono generati i pattern event del nodo corrente, che vengono inviati a uno o più nodi del livello superiore;
\item un insieme $P$ di dichiarazioni di pattern;
\item un insieme $L_{patt}$ di link uscenti da terminali di input del nodo ed entranti in terminali di input dei componenti.
\end{itemize}
Quest'ultima caratteristica aggiuntiva consente l'invio dei pattern event in ingresso al nodo ai componenti particolari predisposti a gestire tali eventi.

\subsection{Pattern}
Una dichiarazione di pattern è una quadrupla $(p,l,r,o)$ dove:
\begin{itemize}
\item $p$ è il nome del pattern event;
\item $l$ è il linguaggio relativo al pattern;
\item $r$ è una espressione regolare;
\item $o \in O$ è un terminale di output in corrispondenza del quale il pattern event viene generato.
\end{itemize}
Il linguaggio $l$ del pattern può variare dal linguaggio minimo, cioè costituito dalle sole transizioni facenti parte dell'espressione regolare $r$, al linguaggio massimo, ovvero corrispondente all'insieme di tutte le transizioni di componenti del nodo. L'appartenenza a diversi linguaggi conferisce una semantica differente a quei pattern le cui espressioni regolari utilizzano operatori insiemistici, come ad esempio il $not$. Si nota facilmente che il complemento di una transizione rispetto a linguaggi differenti ha come risultato una unione di transizioni che, data l'operazione di complemento applicata su insiemi diversi, varia.

\subsection{Pattern space}
In modo da individuare pattern event, deve essere mantenuto lo stato relativo al matching dei pattern coinvolti. A tal fine, per ogni nodo, è necessario generare degli automi, chiamati \emph{pattern space}, secondo i seguenti passi:
\begin{itemize}
\item per ogni pattern $(p,l,r,o)$, viene generato un automa deterministico equivalente all'espressione regolare $r$, nel quale ogni stato finale viene marcato dal nome $p$ del pattern event;
\item per ogni linguaggio utilizzato nella definizione dei pattern, vengono identificati i pattern che utilizzano tale linguaggio, corrispondenti agli automi $[A_1, \ldots , A_k]$, e viene generato un pattern space nel seguente modo:
	\begin{enumerate}
	\item un automa non deterministico $N$ è creato generando il suo stato iniziale $s_0$ e una $\epsilon$-			transizione da $s_0$ a ogni stato iniziale di $A_i$, con $i \in [1 \ldots k]$;
	\item in modo da mantenere il matching di stringhe sovrapposte, viene aggiunta una $\epsilon$-transizione	da ogni stato non iniziale a $s_0$;
	\item l'automa $N$ viene determinizzato nel risultante pattern space $Pts$, dove ogni stato finale $s_f$ è marcato dall'unione \textbf{p} dei pattern event associati agli stati in $s_f$ che sono finali nei corrispondenti automi di pattern generati inizialmente. Ogni stato $s$ dell'automa deterministico $Pts$ è infatti identificato da un sottoinsieme di stati dell'automa non deterministico equivalente $N$.
	\end{enumerate}
\end{itemize}

\begin{ex}
Viene di seguito presentata la costruzione del pattern space relativo a due pattern (caratterizzati ovviamente dallo stesso linguaggio).
\end{ex}

\subsection{Link tra nodi}
Un sistema attivo complesso, oltre che da un insieme di nodi, è caratterizzato dalla topologia con cui i nodi sono collegati tra loro. Si assume che tale topologia generi un albero.
I nodi sono tra loro connessi per mezzo di link. I link tra nodi sono definiti analogamente ai link tra componenti del singolo sistema attivo, con la differenza che i primi connettono tra loro sistemi attivi.
In un SAC ogni link esce da un terminale di output $o$ di un nodo $n$ e entra in un terminale di input $i$ di un nodo $n^\prime$.
I link sono caratterizzati da un modello, che costituisce un'astrazione del link specifico in esame.

\begin{defn}
Un modello di un link è una quadrupla
\begin{center}
	$M_{l_c} = (i,o,z,w)$
\end{center}
dove $i$ è il terminale di input, $o$ il terminale di output, $z$ la dimensione e $w$ la politica di saturazione.
\end{defn}
Un particolare link $l_c$ è un'istanza di un modello siffatto, e consiste quindi in un canale di comunicazione unidirezionale fra due nodi del sistema $n$ e $n^\prime$, dove un terminale di output $o$ di $n$ e un terminale di input $i$ di $n^\prime$ coincidono rispettivamente con l'input e l'output del link $l_c$.
La dimensione $z$ rappresenta il numero massimo di eventi che possono essere accodati nel link. 
Indichiamo con $|l_c|$ la configurazione corrente del link. 
Se il numero di eventi attualmente memorizzati coincide con la dimensione, il link si dice essere saturo.
Quando il link è saturo, la semantica legata al compimento delle transizioni è dettata dalla politica di saturazione $w$ (si veda il paragrafo \ref{saturation}).
Come per i link tra componenti, anche per quanto riguarda i link tra nodi, nel seguito della trattazione, si farà riferimento al caso in cui la dimensione sia unitaria e la politica di saturazione sia $wait$.

\subsection{Sistema attivo complesso}
Un sistema attivo complesso è una rete di nodi interconnessi per mezzo di link. Ogni nodo ed ogni link del sistema sono caratterizzati da un modello e quindi, in generale, più elementi potrebbero avere il medesimo modello. Si assume che più link possano uscire da un terminale di output di un nodo, mentre al massimo un link possa entrare in un terminale di input.

\begin{defn}
Un sistema attivo complesso è una coppia
\begin{center}
	$ C = (N,L_c)$
\end{center}
dove $N$ è l'insieme di nodi, mentre $L_c$ è l'insieme dei link tra terminali di nodi appartenenti a $N$.
\end{defn}


\subsection{Traiettoria}
Un SAC può essere pensato come una macchina che può essere in uno stato quiescente o in uno stato reattivo. Se si trova nello stato quiescente, i componenti non effettuano alcuna transizione, dal momento che nessun evento è disponibile nei terminali di ingresso. In corrispondenza del verificarsi di un determinato evento proveniente dal mondo esterno, il sistema evolve nella sua fase reattiva. Dato che il comportamento del sistema è asincrono (non dipende dal tempo), la reazione, detta traiettoria (o storia), consiste in una sequenza di transizioni compiute da componenti presenti nel sistema.
Ogni transizione di un componente porta il sistema in un nuovo stato, dove uno stato è identificato dallo stato corrente di ogni componente di ogni nodo,dalle configurazioni attuali dei link dei nodi e dallo stato attuale dei pattern space di tutti i nodi. Quando un pattern space raggiunge uno stato finale, il relativo pattern event viene inviato al terminale corrispondente.
In altre parole, uno stato del sistema attivo complesso è una tripla $(S,Q,Pts)$, dove $S$ è la n-pla degli stati dei componenti dei nodi, $Q$ è la m-pla delle configurazioni dei link tra nodi, mentre $Pts$ è la p-pla di pattern space di tutti i nodi.
Quindi una transizione del sistema può essere scritta come:
\begin{center}
	$T = (S,Q,Pts) \xrightarrow {t(c(n))} (S^\prime,Q^\prime,Pts^\prime)$,
\end{center}
dove $t(c(n))$ identifica univocamente la transizione $t$ appartenente al modello del componente $c$ nel nodo $n$.
Assumendo che $a_0 = (S_0,Q_0,Pts_0)$ sia lo stato iniziale del sistema, la traiettoria ottenuta partendo da $a_0$ è la sequenza di stati del sistema determinata dall'occorrenza di transizioni $t_1, \ldots , t_k$ attuabili da parte dei singoli componenti dei nodi:
\begin{center}
$h = a_0 \xrightarrow{t_1(c_1(n_1))} a1 \xrightarrow{t_2(c_2(n_2))} a2 \ldots \xrightarrow{t_k(c_k(n_k))} a_k$.
\end{center}

Ogni stato (non iniziale) dipende quindi dallo stato precedente e dalla particolare transizione che lo porta allo stato corrente, ovvero la coppia $(a_{i-1},t_i(c_i(n_i)))$. Assumendo che si parta dallo stato iniziale $a_0$ questo ci permette di identificare una traiettoria per mezzo delle sole transizioni dei componenti dei nodi:
\begin{center}
$h = [t_1(c_1(n_1)),t_2(c_2(n_2)), \ldots , t_k(c_k(n_k))]$.
\end{center}


\subsection{Behavior space}
Dato un SAC $C$ ed il suo stato iniziale, possono esservi infinite traiettorie, descritte da un automa. 
Quest'ultimo è detto behavior space e ha come alfabeto l'intero insieme delle transizioni dei singoli componenti di ogni nodo.
Il linguaggio del behavior space $Bsp(C)$ con stato iniziale $a_0$ coincide con l'insieme di tutte le possibili traiettorie del sistema $C$ partendo dallo stato $a_0$. 
\begin{defn}
Sia $C = (N,L)$ un sistema attivo complesso, dove $N$ è l'insieme di nodi, mentre $L$ è l'insieme di link tra i nodi. Il behavior space di $C$ è il DFA
\begin{center}
	$Bsp(C) = (\Sigma,\alpha,\tau,a_0)$
\end{center}
dove:
\begin{enumerate}
\item $\Sigma$ è l'alfabeto, dato dall'unione delle transizioni dei componenti di tutti i nodi in $N$;
\item $\alpha$  è l'insieme degli stati $(S,Q,Pts)$, con $S = (s_1,\ldots,s_n)$ una n-pla di stati dei componenti in ogni nodo in $N$, $Q = (q_1, \ldots,q_m)$ una m-pla di configurazioni dei link interni ai nodi in $N$, e $Pts = (pts_1, \ldots, pts_p)$ una p-pla di stati dei pattern space di tutti i nodi in $N$;
\item $a_0 = (S_0,Q_0,Pts_0)$ è lo stato iniziale;
\item $\tau$ è la funzione di transizione deterministica, $\tau: \alpha \times \Sigma \rightarrow \alpha$, tale che 
\begin{center}
$(S,Q,Pts) \xrightarrow{t(c(n))} (S^\prime, Q^\prime, Pts^\prime) \in \tau$,
\end{center}
dove $S = (s_1, \ldots,s_n)$, $Q = (q_1, \ldots,q_m)$, $Pts = (pts_1, \ldots, pts_p)$, $S^\prime = (s^\prime_1, \ldots,s^\prime_n)$, $Q^\prime = (q^\prime_1, \ldots,q^\prime_m)$, $Pts^\prime = (pts_1^\prime, \ldots, pts_p^\prime)$ e
\begin{center}
$t(c(n)) = s \xrightarrow{(e,x) | \{(e_1,y_1), \ldots, (e_p,y_p)\}} s^\prime$
\end{center}
se e solo se:
\begin{itemize}
\item $x = In$, cioè l'evento è disponibile sul terminale di input virtuale sensibile agli eventi esterni al sistema;
\item Per ogni $i \in [1 \ldots n]$, abbiamo
\begin{center}
$s^\prime_i = \begin{cases} s^\prime & \mbox{se }c_i = c\\ s_i & \mbox{altrimenti} \end{cases}$
\end{center}
cioè per ogni transizione del behavior space cambia lo stato relativo al singolo componente coinvolto nella transizione;
\item $Pts^\prime$ differisce d $Pts$ solo negli elementi $w \in [j, \ldots, k]$ corrispondenti a pattern space del nodo $n$ coinvolto nella transizione, secondo il seguente comportamento:
\begin{center}
$Pts^\prime(P_w) = \begin{cases} \overline{Pts} & \mbox{se esite}Pts(P_w) \xrightarrow{t(c(n))} \overline{Pts}\\ P_{w,0} & \mbox{altrimenti} \end{cases}$;
\end{center}
\item $Q^\prime$ differisce da $Q$ per le seguenti condizioni:
\begin{itemize}
\item $Q(x) = e \rightarrow Q^\prime(x) = \epsilon$, cioè l'evento in input è consumato;
\item $\forall(e_j,y_j), j \in [1 \ldots p], Q(y_j) = \epsilon \rightarrow Q^\prime(y_j) = e_j$, cioè gli eventi di uscita sono inseriti nei terminali di input connessi ai terminali di output coinvolti nella transizione;
\item se $Pts^\prime(P_w) \neq Pts(P_w), w \in [j, \ldots, k], Pts^\prime(P_w)$ è finale e marcato dall'insieme di eventi \textbf{p}, allora ogni $p_i \in \textbf{p}$  ha un terminale destinazione $o_i \in O$ del nodo $n$. Ogni terminale di output di $n$ è collegato ad uno o più terminali di input di un nodo superiore $n^\prime$, che a sua volta è collegato ad uno o più terminali di input $i_z$ che gestiscono il patter event. Per ogni terminale $i_z$, il relativo contenuto passa da $\epsilon$ al pattern event $p_i$.
\end{itemize}
\end{itemize}
\end{enumerate}
\end{defn}


\newpage
\section{Problema di diagnosi}
Analogamente al caso di sistemi attivi tradizionali, il problema di diagnosi dei sistemi attivi complessi necessita di informazioni riguardanti l'osservabilità  i guasti delle transizioni di ogni nodo. Si suppone sia disponibile, terminata la reazione, l'osservazione riferita ad ogni singolo sistema attivo che compone il sistema. Si ricorda che nell'ambito di questo lavoro ci si focalizza sulla cosiddetta diagnosi a posteriori, ovvero a seguito di una traiettoria completa del SAC, che parte da uno stato iniziale noto quiescente e termina in uno stato finale (sconosciuto a priori) anch'esso quiescente. 

\subsection{Viewer}
Per ogni nodo un viewer locale specifica quali transizioni sono osservabili, associando ad esse una label. Il viewer globale del sistema $C$ è la composizione dei viewer locali dei sistemi attivi appartenenti ad $N$, $V = (V_{n_1}, \ldots, V_{n_n})$. Ogni viewer locale è definito come una coppia $(t,l)$ che associa alla transizione $t$ la label $l$.

\subsection{Osservazione temporale}
L'osservazione $O$ di un SAC è una n-pla di osservazioni locali dei singoli nodi del sistema $O = (O_{n_1}, \ldots, O_{n_n})$. Ogni osservazione locale è una sequenza di label osservabili.

\subsection{Ruler}
L'informazione riguardante le transizioni di guasto è fornita, per ogni nodo del SAC, dal ruler locale. Il ruler globale del sistema $C$ è una n-pla di ruler locali, $R = (R_{n_1}, \ldots, R_{n_n})$. Ogni ruler locale è definito come una coppia $(t,f)$ che associa alla transizione $t$ la label di guasto $f$.

\subsection{Problema di diagnosi}
Diagnosticare il comportamento di un SAC equivale a trovare i guasti nella sua traiettoria. Quest'ultima, a causa della ridotta osservabilità del sistema, è percepita solo attraverso una traccia, a cui potrebbero però essere associate più traiettorie, anche infinite. Per questo motivo il risultato della diagnosi è un insieme di diagnosi candidate, con ogni candidato che corrisponde ad un sottoinsieme di possibili traiettorie. 
\begin{defn}
Un problema di diagnosi per un SAC $C$ è una quadrupla
\begin{center}
$P(C) = (a_0,V,O,R)$,
\end{center}
dove:
\begin{itemize}
\item $a_0$ è lo stato iniziale del sistema $C$;
\item $V$ è il viewer globale di $C$, composto dall'insieme dei viewer locali $V_{n_1}, \ldots, V_{n_n}$;
\item $O$ è l'osservazione globale, formata dall'insieme di osservazioni locali $O_{n_1}, \ldots, O_{n_n}$;
\item $R$ è il ruler globale di $C$, contenente l'insieme dei ruler locali $R_{n_1}, \ldots, R_{n_n}$.
\end{itemize}
\end{defn}

Concettualmente, è possibile definire la soluzione di un problema di diagnosi nel seguente modo.
\begin{defn}
Sia $P(C) = (a_0,V,O,R)$ un problema di diagnosi per il SAC $C$, e sia $Bsp(C)$ il behavior space con stato iniziale $a_0$. La soluzione del problema di diagnosi $\Delta(P(C))$, è l'insieme di diagnosi:
\begin{center}
	$\Delta(P(C)) = \{ \delta | \delta = h_{[R]}, h \in Bsp(C), h_{[V]} = O\}$
\end{center}
\end{defn}
In altre parole, la soluzione di un problema di diagnosi è l'insieme costituito dagli insiemi di guasti rilevati lungo le traiettorie la cui traccia è consistente con l'osservazione temporale.


\newpage
\section{Diagnosi monolitica}
Analogamente al metodo di diagnosi monolitico visto per i sistemi attivi tradizionali, anche per i SAC è possibile adottare un procedimento analogo. Il behavior dato dalla ricostruzione monolitica racchiude tutte le possibili traiettorie del sistema che sono consistenti con le sequenze di osservazioni temporali locali dei vari nodi.
Il behavior di un SAC differisce da quello visto nel capitolo precedente per il fatto di avere alcune informazioni aggiuntive contenute negli stati: lo stato attuale dei pattern space e l'osservazione che non è più un solo indice ma una n-pla di indici, ognuno relativo alla consumazione dell'osservazione locale di un nodo.

\subsection{Ricostruzione del behavior}
Il primo passo della diagnosi monolitica consiste nella ricostruzione del behavior, ovvero del DFA contenente tutte le traiettorie del sistema consistenti con le osservazioni temporali.
\begin{defn}
Sia $P(C) = (a_0,V,O,R)$ un problema di diagnosi per un sistema attivo complesso $C = (N,L)$, dove $N$ è un insieme di nodi, mentre $L$ è un insieme di link tra i nodi. Sia $I(O)$ l'insieme delle sequenze di indici $[0 \ldots i_{n_f}]$ che rappresentano le consumazioni delle osservazioni di lunghezza $i_{n_f}$ di ogni nodo $n$ del sistema, con $0$ corrispondente all'indice relativo all'osservazione iniziale nulla. 
Il behavior spurio di $P(C)$ è l'automa deterministico
\begin{center}
	$Bhv^s(P(C)) = (\Sigma,B^s,\tau^s,\beta_0,\beta_f)$
\end{center}
dove:
\begin{itemize}
\item $\Sigma$ è l'alfabeto, costituito dall'unione delle transizioni dei componenti di ogni nodo in $N$;
\item $B^S$ è l'insieme di stati $(S,Q,Pts,i_n)$, con $S = (s_1,\ldots,s_n)$ la n-pla di stati di tutti i componenti di tutti i nodi in $N$, $Q = (q_1,\ldots,q_m)$ la m-pla delle configurazioni di tutti i link di ogni nodo, $Pts = (Pts_1,\ldots,Pts_p)$ gli stati relativi ai pattern space di tutti i nodi, e $i_n$ gli indici correnti delle osservazioni locali dei nodi;
\item $\beta_0 = (S_0,Q_0,Pts_0,I_0)$ è lo stato iniziale, dove $a_0 = (S_0,Q_0)$, $Pts_0 = (Pts_{10},\ldots,Pts_{p_0})$ cioè la p-pla degli stati iniziali di tutti i pattern space, $I_0 = (0,\ldots,0)$ gli indici iniziali nulli degli stati delle osservazioni locali;
\item $\tau^s$ è la funzione di transizione, $\tau^s: B^s \times \Sigma \rightarrow B^s$, dove $(S,Q,Pts,I) \xrightarrow{t(c(n))} (S^\prime,Q^\prime,Pts^\prime,I^\prime) \in \tau^s$ e 
\begin{center}
	$t(c(n)) = s \xrightarrow{(e,x) | \{(e_1,y_1), \ldots, (e_p,y_p)\}} s^\prime$
\end{center}
con $e$ disponibile in corrispondenza del terminale di input $x$, oppure nullo se rappresenta un evento esterno.
Per ogni $j \in [1 \ldots n]$:
\begin{center}
$s^\prime_j = \begin{cases} s^\prime & \mbox{se }c_j = c\\ s_j & \mbox{altrimenti} \end{cases}$
\end{center}
cioè per ogni transizione del behavior space cambia lo stato relativo al singolo componente coinvolto nella transizione.
L'inserimento degli eventi in uscita varia in base alla politica di saturazione.
Nel caso $t(c(n))$ sia osservabile, essa deve essere presente nel viewer $V$ associata alla label $l$ e quest'ultima è una label contenuta nella sequenza di osservazione $O_n$ del nodo $n$ in corrispondenza dell'indice successivo $i_n+1$, il quale viene aggiornato; nel caso invece $t(c(n))$ non sia osservabile, l'indice dell'osservazione rimane immutato;
\item $\beta_f$ è l'insieme degli stati finali $(S_f,Q_f,Pts_f,I_f)$, dove $I_f$ è la n-pla di indici finali delle sequenze di osservazione locali.
\end{itemize}
\end{defn}

Il behavior $Bhv(P(C)) = (\Sigma,B,\tau,\beta_0,\beta_f)$ è ottenuto rimuovendo dal behavior spurio tutti gli stati e tutte le transizioni che non appartengono a nessun cammino tra lo stato iniziale e uno degli stati finali (operazione di trim).
La definizione di behavior è ottenuta dalla definizione di behavior space, secondo le seguenti variazioni:
\begin{enumerate}
\item ogni stato del behavior include un campo aggiuntivo, la n-pla di indici $I$ delle sequenze di osservazioni locali di ogni nodo;
\item la funzione di transizione richiede un requisito aggiuntivo di consistenza con le osservazioni temporali, nel caso la transizione sia osservabile;
\item il behavior possiede degli stati finali, che indicano il raggiungimento della completa consumazione delle sequenze osservate per ogni nodo;
\item nel passaggio dal behavior spurio al behavior, sono mantenuti solo gli stati e le transizioni incluse in un cammino dallo stato iniziale ad uno stato finale.
\end{enumerate}
Secondo le definizioni viste in precedenza, quindi, il linguaggio del behavior costituisce un sottoinsieme del linguaggio del behavior space, in quanto costituito unicamente da quelle traiettorie che sono consistenti con l'osservazione temporale.

\subsection{Decorazione}
L'algoritmo di decorazione è esattamente quello visto nel capitolo precedente. Si noti che in questo caso l'associazione delle etichette di guasto alle transizioni avviene considerando il ruler locale del nodo $n$ il cui componente è coinvolto nella transizione $t(c(n))$. 

\subsection{Distillazione delle diagnosi}
Una volta decorato il behavior, è possibile generare l'insieme delle soluzioni candidate esattamente come analizzato nel capitolo precedente.


\newpage
\section{Diagnosi distribuita}
Il metodo di ricostruzione monolitica, analizzato nei paragrafi precedenti, è inefficiente in quanto la complessità della generazione del behavior globale è in generale esponenziale nel numero di componenti totali, nel numero di link totali, nel numero dei pattern space e nel numero dei nodi (ad ognuno dei quali corrisponde una sequenza di osservazione). Sebbene la ricostruzione permetta di non ricostruire il comportamento globale del sistema (behavior space), la ricostruzione del behavior è comunque costosa, sia in termini di tempo di esecuzione, sia soprattutto di memoria.
Per questo motivo, nel corso di questo lavoro di tesi, è stato sviluppato un algoritmo distribuito, che ricostruisce il comportamento del singolo nodo, unitamente alle informazioni necessarie scaturite dai pattern event, in modo da non dover generare il behavior globaledel sistema. Per fare questo si è seguita la topologia del sistema: essendo una gerarchia, l'algoritmo opera in maniera bottom-up partendo dai nodi foglia. Il comportamento di questi ultimi, infatti, non è vincolato dal comportamento di nessun altro nodo, quindi la loro ricostruzione è esattamente quella vista nel paragrafo precedente, eccetto il fatto che si considera il singolo nodo e non l'intero sistema. Per poter ricostruire i comportamenti dei nodi nel livello superiore della gerarchia, invece, è necessario considerare i pattern event che vengono inviati dal livello base. Per fare questo, viene creata, per ogni nodo foglia, una interfaccia ottenuta togliendo dal linguaggio del behavior locale tutte quelle transizioni che non portano alla generazione di un pattern event nei corrispondenti terminali di uscita del nodo. I comportamenti del livello superiore, quindi, sono ricostruiti tenendo conto delle interfacce dei nodi sottostanti da cui essi dipendono. Ogni passaggio di stato dell'interfaccia sottostante corrisponde alla generazione di un patter event che può essere consumato dai componenti a livello superiore. Il procedimento viene reiterato per ogni strato della gerarchia del sistema.
Una volta raggiunta la radice dell'albero, non è più necessario generare l'interfaccia di tale nodo (dato che nessun pattern event viene gestito da un livello superiore), quindi l'unico behvaior corrispondente racchiude in sé tutte le diagnosi dell'intero sistema, ma in forma sintetica. La sua decorazione permette di ricavare l'insieme di diagnosi candidate del SAC.

\subsection{Costruzione del Behavior non vincolato}
La ricostruzione dei behavior dei nodi foglia del SAC è un caso particolare della ricostruzione monolitica. Le variazioni consistono nel considerare solo i pattern space relativi al nodo locale e unicamente l'osservazione locale, la cui consumazione viene monitorata per mezzo di un unico indice di sequenza. Analogamente il viewer e il ruler possono essere ristretti rispettivamente al viewer locale e al ruler locale del nodo corrente, in quanto si considerano solo transizioni di componenti appartenenti al nodo in esame.

\subsection{Generazione dell'interfaccia}
L'interfaccia di un nodo è un automa ottenuto eliminando dal linguaggio del behavior locale tutte le transizioni che non generano un pattern event.
La costruzione avviene come di seguito.
\begin{enumerate}
\item L'identificatore di una transizione di un componente $t(c)$ che provoca la generazione di un pattern event $(p,r,o)$ viene sostituito dal nome $p$ del pattern event generato, unitamente alla diagnosi relativa alla singola transizione che può essere:
\begin{itemize}
\item l'insieme singleton $\{\emptyset\}$ se la transizione è normale;
\item l'insieme singleton $\{\{f\}\}$, se la transizione è di guasto e $f$ è la corrispondente label associata nel ruler.
\end{itemize}
\item Le transizioni non associate ad alcun evento di pattern vengono interpretate come $\epsilon$-transizioni, ottenendo in questo modo un automa non deterministico (NFA). Quest'ultimo viene determinizzato attraverso un algoritmo simile alla subset construction: differisce da quest'ultima poichè la determinizzazione non si basa esclusivamente sui singoli stati del NFA, ma su tutta la sua struttura (pattern event e diagnosi relativa).
\end{enumerate}

\subsection{Costruzione del Behavior vincolato}
La costruzione del behavior vincolato riguarda tutti i nodi che non sono dei nodi foglia nella topologia del sistema. Per questo tipi di nodi, la ricostruzione del comportamento deve tenere conto delle informazioni aggiuntive riguardanti i pattern event che giungono dal livello inferiore. Questa informazione è racchiusa nelle interfacce dei nodi inferiori da cui il nodo corrente dipende. Un nodo dipende da un nodo di un livello inferiore se esiste un link che unisce un terminale di output da quel nodo inferiore al terminale di input del nodo in esame. Lo stato del behavior corrente, quindi, possiede l'informazione aggiuntava che riguarda la tupla di stati relativi alle interfacce da cui il nodo corrente dipende. Una transizione del comportamento può quindi essere di due tipi:
\begin{itemize}
\item una transizione $t(c)$ relativa ad un componente del nodo;
\item una transizione $t(Int)$ relativa ad una delle interfacce.
\end{itemize} 
Si noti che l'ultima è effettuabile se i link dove vengono generati i pattern event sono liberi (secondo la politica di saturazione wait adottata in questo lavoro).
Uno stato finale del behavior vincolato è tale se, oltre ad ever consumato completamente l'osservazione del nodo locale, ha raggiunto gli stati finali di tutte le interfacce da cui esso dipende. Quest'ultimo vincolo è necessario in quanto, proseguendo bottom-up nella ricostruzione, è necessario che ogni nodo abbia consumato la propria osservazione, affinché uno stato finale possa essere considerato il culmine di una traiettoria completa.

\subsection{Decorazione del Behavior del nodo radice}
Una volta che il metodo di ricostruzione distribuito raggiunge il nodo radice ed è stata effettuata la ricostruzione del behavior di quest'ultimo, è necessario effettuarne la decorazione, in maniera simile a quanto visto per il caso monolitico, con due variazioni:
\begin{itemize}
\item attraversando una transizione relativa a una interfaccia, è necessario combinare la diagnosi dello stato di partenza con la diagnosi associata alla transizione di interfaccia, mentre per le transizioni relative a componenti del nodo locale si mantiene il solito approccio, ricercando nel ruler se la transizione è presente e con quale label;
\item quando la decorazione raggiunge uno stato finale, bisogna combinare la diagnosi ottenuta con la diagnosi relativa agli stati finali dell'interfaccia.
\end{itemize}
La seconda modifica è necessaria al fine di avere una diagnosi completa poiché, mentre negli stati non finali dell'interfaccia poi vi è una transizione con le relative diagnosi contenute nello stato, in corrispondenza dello stato finale mancano quelle diagnosi appartenenti a quello stato, che è finale senza la necessità di dover percorrere ulteriori transizioni per raccoglierne le diagnosi.