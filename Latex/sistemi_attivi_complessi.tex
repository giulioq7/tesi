\chapter{Sistemi Attivi Complessi}
In questo capitolo vengono presentate definizioni e modelli che descrivono i sistemi attivi complessi, visti come estensione dei sistemi attivi tradizionali descritti precedentemente. Un sistema attivo complesso è una gerarchia di sistemi attivi tra loro comunicanti. Questo modello si ispira a molti sistemi naturali, fisici, economici e sociali, dei quali è possibile fornire un modello stratificato, in base a diversi livelli di astrazione. Nei sistemi biologici, ad esempio, il comportamento può essere descritto a basso livello dalle interazioni fra le cellule, oppure ad un livello più alto tra i tessuti, o ancora in maniera più astratta studiando il funzionamento degli organi. Nell'ambito dei linguaggi di programmazione a oggetti, ad esempio, a basso livello vi sono le singole istruzioni, a livello più alto i metodi, ad un più alto livello ancora le classi e le interfacce. 
L'attributo ``complesso'' si riferisce, più che alla quantità di componenti presenti nel sistema (che comunque possono essere molti), all'organizzazione gerarchica e alla conseguente stratificazione del comportamento globale del sistema.
Ogni livello della gerarchia di sistemi siffatti ha una evoluzione indipendente dagli altri, eccetto alcune informazioni che giungono dai livelli sottostanti. Ogni livello, in altre parole, ha un comportamento emergente che è impredicibile dalla semplice conoscenza del comportamento dei singoli componenti. Queste informazioni che giungono ai livelli superiori sono resi nel modello dei sistemi attivi complessi attraverso pattern event, che si verificano quando determinate configurazioni delle transizioni dei componenti sottostanti si verificano, soddisfacendo particolari espressioni regolari.

\section{Definizioni}
Un sistema attivo complesso (SAC) è una gerarchia di sistemi attivi. In un SAC, vi sono due tipi di comunicazione: tra componenti dello stesso sistema attivo e tra differenti sistemi attivi. 
I componenti di un sistema attivo interagiscono tra loro in base a determinati eventi che giungono o da componenti adiacenti (eventi interni), o da altri sistemi attivi collegati (pattern event) o dal mondo esterno al sistema (eventi esterni). Questi eventi innescano delle transizioni nei componenti, le quali a loro volta generano nuovi eventi, formando una sequenza di transizioni detta traiettoria del SAC.
Analogamente ai sistemi attivi tradizionali, un sistema attivo complesso può essere in uno stato quiescente, nel quale nessun evento si verifica e conseguentemente non vengono innescate transizioni dei componenti.
Il SAC diviene reattivo nel momento in cui si verifica un evento esterno che può essere consumato da un componente. In tale circostanza la transizione di un componente modifica lo stato del sistema, dove lo stato è caratterizzato dalla composizione di tutti gli stati dei componenti, dagli eventi non ancora consumati presenti nei terminali di input, e dagli stati relativi agli automi (pattern space) responsabili del matching delle espressioni regolari generanti i pattern event. 

\subsection{Nodi}
Un sistema attivo complesso è composto da un insieme di sistemi attivi che interagiscono tra loro. Ogni singolo sistema attivo è detto nodo, in quanto costituisce un nodo nella gerarchia che caratterizza la topologia del sistema.
Il modello di un nodo, a cui più istanze di nodi possono fare riferimento, possiede tutti gli attributi di un sistema attivo, con l'aggiunta di alcuni elementi:
\begin{itemize}
\item un insieme $I$ di terminali di input, nei quali giungono pattern event generati da nodi del livello inferiore;
\item un insieme $O$ di terminali di output, nei quali vengono generati i pattern event del nodo corrente, che vengono inviati a uno o più nodi del livello superiore;
\item un insieme $P$ di dichiarazioni di pattern.
\end{itemize}

\subsection{Pattern}
Una dichiarazione di pattern è una tripla $(p,r,o)$ dove:
\begin{itemize}
\item $p$ è il nome del pattern event;
\item $r$ è una espressione regolare;
\item $o \in O$ è un terminale di output in corrispondenza del quale il pattern event viene generato.
\end{itemize}

\subsection{Pattern space}
In modo da individuare pattern event, deve essere mantenuto lo stato relativo al matching dei pattern coinvolti. A tal fine, per ogni nodo, è necessario effettuare i seguenti passi:
\begin{itemize}
\item per ogni pattern $(p,r,o)$, viene generato un automa deterministico equivalente all'espressione regolare $r$, nel quale ogni stato finale viene marcato dal nome $p$ del pattern event;
\item per ogni linguaggio utilizzato nella definizione dei pattern, supponendo che sia condiviso da $k$ definizioni pattern corrispondenti agli automi $[A_1, \ldots , A_k]$ viene generato un pattern space, nel seguente modo:
	\begin{enumerate}
	\item un automa non deterministico $N$ è creato generando il suo stato iniziale $S_0$ e una $\epsilon$-			transition da $S_0$ a ogni stato iniziale di $A_i$, con $i \in [1 \ldots k]$;
	\item in modo da mantenere il matching di stringhe sovrapposte, viene aggiunta una $\epsilon$-transition
	da ogni stato non iniziale a $S_0$;
	\item l'automa $N$ viene determinizzato nel risultante pattern space $Pts(L)$, dove ogni stato finale $S$ è marcato dall'unione $p$ dei pattern event associati agli stati in $S$ che sono finali nei corrispondenti automi di pattern generati inizialmente. Ogni stato $S$ dell'automa deterministico $Pts(L)$ è infatti identificato da un sottoinsieme di stati dell'automa non deterministico equivalente $N$.
	\end{enumerate}
\end{itemize}

\begin{ex}
Viene di seguito presentata la costruzione del pattern space relativo a due pattern (caratterizzati ovviamente dallo stesso linguaggio).
\end{ex}

\subsection{Link tra nodi}
Un sistema attivo complesso, oltre che da un insieme di nodi, è caratterizzato dalla topologia con cui i nodi sono collegati tra loro. Si assume che tale topologia generi un albero.
I nodi sono tra loro connessi per mezzo di link. I link tra nodi sono definiti analogamente ai link tra componenti del singolo sistema attivo, con la differenza che i primi connettono tra loro sistemi attivi.
In un SAC ogni link esce da un terminale di output $o$ di un nodo $n$ e entra in un terminale di input $i$ di un nodo $n^\prime$.
I link sono caratterizzati da un modello, che costituisce un'astrazione del link specifico in esame.

\begin{defn}
Un modello di un link è una quadrupla
\begin{center}
	$M_{l_c} = (i,o,z,w)$
\end{center}
dove $i$ è il terminale di input, $o$ il terminale di output, $z$ la dimensione e $w$ la politica di saturazione.
\end{defn}
Un particolare link $l_c$ è un'istanza di un modello siffatto, e consiste quindi in un canale di comunicazione unidirezionale fra due nodi del sistema $n$ e $n^\prime$, dove un terminale di output $o$ di $n$ e un terminale di input $i$ di $n^\prime$ coincidono rispettivamente con l'input e l'output del link $l_c$.
La dimensione $z$ rappresenta il numero massimo di eventi che possono essere accodati nel link. 
Indichiamo con $|l_c|$ la configurazione corrente del link. 
Se il numero di eventi attualmente memorizzati coincide con la dimensione, il link si dice essere saturo.
Quando il link è saturo, la semantica legata al compimento delle transizioni è dettata dalla politica di saturazione $w$ (si veda il paragrafo \ref{saturation}).
Come per i link tra componenti, anche per quanto riguarda i link tra nodi, nel seguito della trattazione, si farà riferimento al caso in cui la dimensione sia unitaria e la politica di saturazione sia $wait$.

\subsection{Sistema attivo complesso}
Un sistema attivo complesso è una rete di nodi interconnessi per mezzo di link. Ogni nodo ed ogni link del sistema sono caratterizzati da un modello e quindi, in generale, più elementi potrebbero avere il medesimo modello. Si assume che più link possano uscire da un terminale di output di un nodo, mentre al massimo un link possa entrare in un terminale di input.

\begin{defn}
Un sistema attivo complesso è una coppia
\begin{center}
	$ C = (N,L)$
\end{center}
dove $N$ è l'insieme di nodi, mentre $L$ è l'insieme dei link tra terminali di nodi appartenenti a $N$.
\end{defn}


\subsection{Traiettoria}
Un SAC può essere pensato come una macchina che può essere in uno stato quiescente o in uno stato reattivo. Se si trova nello stato quiescente, i componenti non effettuano alcuna transizione, dal momento che nessun evento è disponibile nei terminali di ingresso. In corrispondenza del verificarsi di un determinato evento proveniente dal mondo esterno, il sistema evolve nella sua fase reattiva. Dato che il comportamento del sistema è asincrono (non dipende dal tempo), la reazione, detta traiettoria (o storia), consiste in una sequenza di transizioni compiute da componenti presenti nel sistema.
Ogni transizione di un componente porta il sistema in un nuovo stato, dove uno stato è identificato dallo stato corrente di ogni componente di ogni nodo,dalle configurazioni attuali dei link dei nodi e dallo stato attuale dei pattern space di tutti i nodi. Quando un pattern space raggiunge uno stato finale, il relativo pattern event viene inviato al terminale corrispondente.
In altre parole, uno stato del sistema attivo complesso è una tripla $(S,Q,Pts)$, dove $S$ è la n-pla degli stati dei componenti dei nodi, $Q$ è la m-pla delle configurazioni dei link tra nodi, mentre $Pts$ è la p-pla di pattern space di tutti i nodi.
Quindi una transizione del sistema può essere scritta come:
\begin{center}
	$T = (S,Q,Pts) \xrightarrow {t(c(n))} (S^\prime,Q^\prime,Pts^\prime)$,
\end{center}
dove $t(c(n))$ identifica univocamente la transizione $t$ appartenente al modello del componente $c$ nel nodo $n$.
Assumendo che $a_0 = (S_0,Q_0,Pts_0)$ sia lo stato iniziale del sistema, la traiettoria ottenuta partendo da $a_0$ è la sequenza di stati del sistema determinata dall'occorrenza di transizioni $t_1, \ldots , t_k$ attuabili da parte dei singoli componenti dei nodi:
\begin{center}
$h = a_0 \xrightarrow{t_1(c_1(n_1))} a1 \xrightarrow{t_2(c_2(n_2))} a2 \ldots \xrightarrow{t_k(c_k(n_k))} a_k$.
\end{center}

Ogni stato (non iniziale) dipende quindi dallo stato precedente e dalla particolare transizione che lo porta allo stato corrente, ovvero la coppia $(a_{i-1},t_i(c_i(n_i)))$. Assumendo che si parta dallo stato iniziale $a_0$ questo ci permette di identificare una traiettoria per mezzo delle sole transizioni dei componenti dei nodi:
\begin{center}
$h = [t_1(c_1(n_1)),t_2(c_2(n_2)), \ldots , t_k(c_k(n_k))]$.
\end{center}


\subsection{Behavior space}
Dato un SAC $C$ ed il suo stato iniziale, possono esservi infinite traiettorie, contenute in un automa. 
Tale automa è chiamato behavior space e ha come alfabeto l'intero insieme delle transizioni dei singoli componenti di ogni nodo.
Il linguaggio del behavior space $Bsp(C)$ con stato iniziale $a_0$ coincide con l'insieme di tutte le possibili traiettorie del sistema $C$ partendo dallo stato $a_0$. 
\begin{defn}
Sia $C = (N,L)$ un sistema attivo complesso, dove $N$ è l'insieme di nodi, mentre $L$ è l'insieme di link. Il behavior space di $C$ è il DFA
\begin{center}
	$Bsp(C) = (\Sigma,\alpha,\tau,a_0)$
\end{center}
dove:
\begin{enumerate}
\item $\Sigma$ è l'alfabeto, dato dall'unione delle transizioni dei componenti di tutti i nodi in $N$;
\item $\alpha$  è l'insieme degli stati $(S,Q,Pts)$, con $S = (s_1,\ldots,s_n)$ una n-pla di stati dei componenti in ogni nodo $n$, $Q = (q_1, \ldots,q_m)$ una m-pla di configurazioni dei link interni ai nodi in $N$, e $Pts = (pts_1, \ldots, pts_p)$ una p-pla di stati dei pattern space di tutti i nodi $n$;
\item $a_0 = (S_0,Q_0,Pts_0)$ è lo stato iniziale;
\item $\tau$ è la funzione di transizione deterministica, $\tau: \alpha \times \Sigma \rightarrow \alpha$, tale che 
\begin{center}
$(S,Q,Pts) \xrightarrow{t(c(n))} (S^\prime, Q^\prime, Pts^\prime) \in \tau$,
\end{center}
dove $S = (s_1, \ldots,s_n)$, $Q = (q_1, \ldots,q_m)$, $Pts = (pts_1, \ldots, pts_p)$, $S^\prime = (s^\prime_1, \ldots,s^\prime_n)$, $Q^\prime = (q^\prime_1, \ldots,q^\prime_m)$, $Pts^\prime = (pts_1^\prime, \ldots, pts_p^\prime)$ e
\begin{center}
$t(c(n)) = s \xrightarrow{(e,x) | \{(e_1,y_1), \ldots, (e_p,y_p)\}} s^\prime$
\end{center}
se e solo se:
\begin{itemize}
\item $x = In$, cioè l'evento è disponibile sul terminale di input virtuale sensibile agli eventi esterni al sistema;
\item Per ogni $i \in [1 \ldots n]$, abbiamo
\begin{center}
$s^\prime_i = \begin{cases} s^\prime & \mbox{se }c_i = c\\ s_i & \mbox{altrimenti} \end{cases}$
\end{center}
cioè per ogni transizione del behavior space cambia lo stato relativo al singolo componente coinvolto nella transizione;
\item in base alla politica di saturazione
\end{itemize}
\end{enumerate}
\end{defn}

\section{Problema di diagnosi}
Analogamente al caso di sistemi attivi tradizionali, il problema di diagnosi dei sistemi attivi complessi necessita di informazioni riguardanti l'osservabilità  i guasti delle transizioni di ogni nodo. Si suppone sia disponibile, terminata la reazione, l'osservazione riferita ad ogni singolo sistema attivo che compone il sistema. Si ricorda che nell'ambito di questo lavoro ci si focalizza sulla cosiddetta diagnosi a posteriori, ovvero a seguito di una traiettoria completa del SAC, che parte da uno stato iniziale noto quiescente e termina in uno stato finale (sconosciuto a priori) anch'esso quiescente. 

\subsection{Viewer}
Per ogni nodo un viewer locale specifica quali transizioni sono osservabili, associando ad esse una label. Il viewer globale del sistema $C$ è la composizione dei viewer locali dei sistemi attivi appartenenti ad $N$, $V = (V_{n_1}, \ldots, V_{n_n})$. Ogni viewer locale è definito come una coppia $(t,l)$ che associa alla transizione $t$ la label $l$.

\subsection{Osservazione temporale}
L'osservazione $O$ di un SAC è una n-pla di osservazioni locali dei singoli nodi del sistema $O = (O_{n_1}, \ldots, O_{n_n})$. Ogni osservazione locale è una sequenza di label osservabili.

\subsection{Ruler}
L'informazione riguardante le transizioni di guasto è fornita, per ogni nodo del SAC, dal ruler locale. Il ruler globale del sistema $C$ è una n-pla di ruler locali, $R = (R_{n_1}, \ldots, R_{n_n})$. Ogni ruler locale è definito come una coppia $(t,f)$ che associa alla transizione $t$ la label di guasto $f$.

\subsection{Problema di diagnosi}
Diagnosticare il comportamento di un SAC equivale a trovare i guasti nella sua traiettoria. Quest'ultima, a causa della ridotta osservabilità del sistema, è percepita solo attraverso una traccia, a cui potrebbero però essere associate più traiettorie, anche infinite. Per questo motivo il risultato della diagnosi è un insieme di diagnosi candidate, con ogni candidato che corrisponde ad un sottoinsieme di possibili traiettorie. 
\begin{defn}
Un problema di diagnosi per un SAC $C$ è una quadrupla
\begin{center}
$P(C) = (a_0,V,O,R)$,
\end{center}
dove:
\begin{itemize}
\item $a_0$ è lo stato iniziale del sistema $C$;
\item $V$ è il viewer globale di $C$, composto dall'insieme dei viewer locali $V_{n_1}, \ldots, V_{n_n}$;
\item $O$ è l'osservazione globale, formata dall'insieme di osservazioni locali $O_{n_1}, \ldots, O_{n_n}$;
\item $R$ è il ruler globale di $C$, contenente l'insieme dei ruler locali $R_{n_1}, \ldots, R_{n_n}$.
\end{itemize}
\end{defn}

Concettualmente, è possibile definire la soluzione di un problema di diagnosi nel seguente modo.
\begin{defn}
Sia $P(C) = (a_0,V,O,R)$ un problema di diagnosi per il SAC $C$, e sia $Bsp(C)$ il behavior space con stato iniziale $a_0$. La soluzione del problema di diagnosi $\Delta(P(C))$, è l'insieme di diagnosi:
\begin{center}
	$\Delta(P(C)) = \{ \delta | \delta = h_{[R]}, h \in Bsp(C), h_{[V]} = O\}$
\end{center}
\end{defn}
In altre parole, la soluzione di un problema di diagnosi è l'insieme costituito dagli insiemi di guasti rilevati lungo le traiettorie la cui traccia è consistente con l'osservazione temporale.

\section{Diagnosi monolitica}
\subsection{Ricostruzione del behavior}

\subsection{Decorazione}

\subsection{Distillazione delle diagnosi}


\section{Diagnosi distribuita}
\subsection{Costruzione del Behavior non vincolato}

\subsection{Generazione dell'interfaccia}

\subsection{Costruzione del Behavior vincolato}

\subsection{Decorazione del Behavior del nodo radice}